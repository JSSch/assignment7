<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Assignment 7</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Assignment 7</h1>
        <p class="header">Blog post on node.js.</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/JSSch/assignment7/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/JSSch/assignment7/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/JSSch/assignment7">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/JSSch">James Schroeder</a></p>


      </header>
      <section>
        <h3>
<a class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>February 25th, 2015</h3>

<p>Today we're going to discuss Node.js.  The class hasn't tackled server side applications yet, instead opting to have us view a 4 year old youtube video lecture by Ryan Dahl, creater of node.js, and a decent tutorial by Alexandru Vladutu, a fellow who contributes heavilly to stackoverflow questions relating to node.js and asynchronous frameworks.  First, what the heck is node.js?  Alexandru says on his website:</p>

<p><code>"Node markets itself as an asynchronous, event-driven framework built on top of Chrome's JavaScript engine and designed for creating scalable network applications. It's basically JavaScript plus a bunch of C/C++ under the hood for things like interacting with the filesystem, starting up HTTP or TCP servers and so on."
</code></p>


<p>So, in plain english, before node or rails or other async infrastructures, we had a request driven architecture where clients would establish a connection with the server to get or send something like some html or what have you, and then the connection would end after that request was done.  With node, that doesn't happen. </p>

<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>What can Node do?</h3>

<p>With node, we can run a webserver application that can handle simultanious requests very efficiently. Since there is no sleep time for the server, it will constantly add new requests to its stack loop and handle them as soon as resources are available via function callbacks instead of having to wait on traditional server call structures with implemented timeouts to manage delays.</p>
          
<p>Imagine a website where you load the page and there are many links to subpages.  You just requested the html for that page, and now that you've completed that transaction, the server would traditionally end the session.  If you were running the server with node, your session would not be over, and if you were to go to a new link hosted on that server, that would be appended to the transaction, cutting out the protocol time between client and server.  It's pretty dang efficient.</p>

<h3>
<a class="anchor" href="#rather-drive-stick" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Power of Being Asynchronous</h3>

Here's something else that's cool about your server running on node.  As requests come in and traditionally tie up an instance on your server, you spend miliseconds handling each request.  As you have higher traffic with hundreds or thousands of users simultanously hitting your website with legitimate requests, you're going to see a huge performance drop for the clients as they're waiting in the stack for requests to be completed.  This time is actually being spent in most cases with your server being idle, and that's one of the use cases which inspired the asynchronous input output approach to handling server requests.  By eliminating the bottleneck of server handshakes and session termination signals, we can just get to the chase and get the data requested out to the clients rapidly.  It's pretty dang cool.



      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
